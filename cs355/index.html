<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <link rel="icon" href="../img/favicon/favicon.ico">

    <title>Noah Sweet | Developer</title>

    <link rel="stylesheet"
      href="../css/highlightjs/default.min.css">
    <script src="../js/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- Bootstrap core CSS -->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template -->
    <link href="../vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">

    <!-- Custom styles for this template -->
    <link href="../css/freelancer.css" rel="stylesheet">

    <!-- Temporary navbar container fix -->
    <style>
    .navbar-toggler {
        z-index: 1;
    }
    
    @media (max-width: 576px) {
        nav > .container {
            width: 100%;
        }
    }
    </style>

</head>

<body class="index" id="page-top">

    <!-- Navigation -->
    <nav class="navbar fixed-top navbar-toggleable-md navbar-light" id="mainNav">
        <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarExample" aria-controls="navbarExample" aria-expanded="false" aria-label="Toggle navigation">
            Menu <i class="fa fa-bars"></i>
        </button>
        <div class="container">
            <a class="navbar-brand" href="#page-top">Turing Complete</a>
        </div>
    </nav>

    <!-- Header -->
    <header class="masthead">
        <div class="container">
            <!-- <img class="img-fluid" src="img/me.png" alt="" width="256px" height="256px"> -->
            <div class="intro-text">
                <span class="name">Turing Complete Systems</span>
                <hr class="star-light">
                <span class="skills">Noah Sweet<br><a style="color:white;" href="ProjectProposal_NoahSweet.pdf" target="_blank">Project Proposal</a></span>
            </div>
        </div>
    </header>

    <!-- Portfolio Grid Section -->
    <section id="turing-machine">
        <div class="container">
            <div>
                <h3>What is Turing Complete?</h3>
                <p>
                    The textbook definition of a Turing Complete System is any set of rules that can govern the simulation of a Turing Machine. 
                    This definition is purely abstract since a turing machine requires an infinitely long sequence of instructions. 
                    <br><br>In a more computational sense, a Turing Complete system is any system that can run a program to output an answer. This definition is loosely tied around
                    the idea of being able to solve some problems. This allows us to have clearly defined point where an idea becomes a language 
                    or system that can solve computational problems.
                </p><br>

                <h3>The Turing Machine</h3>
                <p>
                    To be turing complete, the textbook mandates that you must simulate a turing machine.
                    A turing machine itself is not a complicated task. There are a defined set of rules that govern
                    the direction, execution, and suspension of the language.

                    <br><br>The machine itself is defined by a read-write <i>head</i>, an infinitely long sequence tape, and
                    the tape being divided into cells that contain 1 symbol. At any given symbol, the machine is defined at some
                    <i>state</i> of its <i>finite state machine</i>. Whenever the machine's head encounters a symbol, the machine
                    performs a lookup into a table that defines all possible states the machine is allowed to be in. For example, if the machine
                    is in State <i>AA</i> and sees an <i>A</i>, an operation may be to erase the A.

                    <br><br>For the suspension of the machine, the machine must define a list of one or more <i>accept states</i>. These
                    are states where the machine encounters a stop executing state. These states prevent all execution from continuing onwards. When the machine
                    enters a <i>accept state</i>, it is seen as the output of the program or it has encountered an error--if the machine's creator
                    decided it so.

                    <br><br>One interesting concept behind a Turing Machine is its <i>description number</i>. This number represents the entire
                    machine from a single integer. There is no strict encoding for how this number is generated from the Turing Machine, only
                    that the machine must be encoded into a single number.

                    <br><br>For a visual version of a Turing Machine I recommend this video. It uses the length of the rods as symbols and contains
                    all rules that a Turing Machine needs.<br><br>

                    <center><iframe width="560" height="315" src="https://www.youtube.com/embed/vo8izCKHiF0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center>
                </p><br>
                <p>Early Sources:
                    <ul>
                        <li><a href="https://medium.com/@evinsellin/what-exactly-is-turing-completeness-a08cc36b26e2">https://medium.com/@evinsellin/what-exactly-is-turing-completeness-a08cc36b26e2</a></li>
                        <li><a href="http://www.ioccc.org/2001/herrmann1.hint">http://www.ioccc.org/2001/herrmann1.hint</a> -- C Preprocessor</li>
                        <li><a href="https://stackoverflow.com/questions/7284/what-is-turing-complete">https://stackoverflow.com/questions/7284/what-is-turing-complete</a> -- User Answers with some references</li>
                        <li><a href="https://en.wikipedia.org/wiki/Turing_machine">https://en.wikipedia.org/wiki/Turing_machine</a> -- Wikipedia</li>
                    </ul>
                </p>

                <br>
                <hr>
                <br>

                <h2>Programming Languages</h2>
                <p>
                    The biggest gist of a turing machine boils down to 4 main features: writing, reading, conditions, and looping. Each one of these features
                    is important in a Turing Machine's ability to read the symbol, lookup its state, commit an action, and move to the next symbol or halt Meeting
                    these 4 basic conditions are found in many turing complete languages, and a factorial demostrates these conditions with recursive looping.
                </p>

                <br>
                <h3>Turing Complete Languages</h3>
                <ul>
                    <li>C (GCC)</li>
                    <li>C (MovCC)</li>
                    <li>C++</li>
                    <li>C++ Templates</li>
                    <li>JavaScript</li>
                    <li>Magic the Gathering</li>
                </ul>

                <h3>Turing Incomplete Languages</h3>
                <ul>
                    <li>Natural Language</li>
                    <li>The C Preprocessor</li>
                </ul>

                <br>

                <p>
                    The following examples examplify a factorial in each language. Factorial utilizes all aspects
                    of a language that make it turing complete:  looping, symbol recognition (+, *, -), and haulting. Just because
                    a language is capable of doing a factorial does not make it turing complete.
                </p>

                <h4>JavaScript</h4>
                <pre>
                    <code>
function factorial(n) {
    if (n == 0) {
        return 1;
    }

    return n * factorial(n - 1);
}

console.log(factorial(4));
                    </code>
                </pre>
                <h4>C</h4>
                    <pre>
                        <code>
#include &lt;stdio.h&gt;

int factorial(int n) {
    if (n == 0) { return 1; }
    return n * factorial(n - 1);
}

int main()
{
    printf("%d", factorial(4));

    return 0;
}
                        </code>
                    </pre>
                <h4>C Preprocessor</h4>
                <p>
                    Inspite of its usefulness the C preprocessor is not a turing complete system. The system does not have a way
                    to detect and move the head in accordance with the dectection. The preprocessor only moves further down the 
                    macro. This also will not allow for anything over 32-bit unsigned max, where as the other Factorials can be
                    quickly adapted to use 64-bit, or even 128-bit, support for numbers larger than 479001600 (12!). 
                    <br><br>
                    The one saving grace of this implementation, is the compiler optimization can will evaluate this expression at compile
                    time, given <i>n</i> is a l-value. This can also be used during runtime, but is not ideal to use as this is really just a bunch
                    of "if...else if" blocks
                </p>
                    <pre>
                        <code>
#define FACT(n) ((n) <= 1 ? 1 : \
                 (n) == 2 ? 2 : \
                 (n) == 3 ? 6 : \
                 (n) == 4 ? 24 : \
                 (n) == 5 ? 120 : \
                 (n) == 6 ? 720 : \
                 (n) == 7 ? 5040 : \
                 (n) == 8 ? 40320 : \
                 (n) == 9 ? 362880 : \
                 (n) == 10 ? 3628800 : \
                 (n) == 11 ? 39916800 : \
                 (n) == 12 ? 479001600 : INT_MAX)
                        </code>
                    </pre>

                    <p>
                        Let's say you did try something like the example below, you would get a warning from the compiler. And an 
                        error from the linker--provided no function matching FACT is found. As an aside, this happens since the preprocessor
                        runs over the file once, and doesn't come back to paste the FACT token again.
                    </p>

                    <pre>
                        <code>
#define FACT(n) (n * FACT(n - 1))
// ---------- 
main.c: In function ‘main’:
main.c:11:22: warning: implicit declaration of function ‘FACT’ [-Wimplicit-function-declaration]
    #define FACT(n) (n * FACT(n - 1))
                        </code>
                    </pre>

                <h4>C++/Metaprogramming</h4>
                <p>
                    Templates have some odd rules about their "Turing Complete"-ness. Sometimes if statements are required
                    in order to terminate the recursive nature, but others leveraging template specialization is the better path.
                    It uses the compiler to add a halt or special action in the recursion. In some cases, like the factorial, you
                    must use specialization to add a halt condition. This factorial is built at compile time, saving a bit of run time.
                    This means that we cannot build a factorial at runtime with user input, a subtle difference in computation vs programming.
                </p>
                    <pre>
                        <code class="C++">
#include &lt;iostream&gt;

template &lt;size_t N&gt;
class Factorial
{
public:
    // N * N - 1
    const static size_t fact = Factorial&lt;N - 1&gt;::fact * N;
};

// Template Specialization for when N == 0
template &lt;&gt;
class Factorial&lt;0&gt;
{
public:
    const static size_t fact = 1;
};


int main()
{
    std::cout &lt;&lt; Factorial&lt;4&gt;::fact;

    return 0;
}
                        </code>
                    </pre>

                    Here is a SFINAE example in C++ templates. This illustrates a use where you can compute if a type is a class.
                    This is mostly used for things like Serialization. I can ask an object if it is a class or a primiative, then
                    send it to the correct serialization function, whether that be a general purpose, class specific, or a primiative
                    type.
                    <br><br>
                    This example is from <a href="http://blog.olivierlanglois.net/index.php/2007/09/01/what_is_the_c_sfinae_principle">Olivir Langlois's Blog</a>

                    <pre>
                        <code>
template &lt;typename T&gt;
class IsClassT {
private:
    // sizeof == 1
    typedef char One;

    // sizeof == 2
    typedef struct { char a[2]; } Two;

    // Class Detection
    template &lt;typename C&gt; static One test(int C::*);

    // Will be chosen if T is anything except a class.
    //   -- since C:: doesn't work on int, float, etc
    template &lt;typename C&gt; static Two test(...);

public:
    // Saves the evaluation for use later
    enum { Yes = sizeof(IsClassT&lt;T&gt;::template test&lt;T&gt;(0)) == 1 };
    enum { No = !Yes };
};
                        </code>
                    </pre>
                <p>
                    This is a further extension of the above SFINAE code to have one serialization call for everything that exist.
                    This will call serialize on an object if able, otherwise it will send it to a general purpose serializer.
                    <br>
                    This uses C++'s decltype and enable_if, although enable_if can be implemented very easily.
                </p>
                <div>
                    <pre>
                        <code>
// C++11
// g++ -std=c++11 -Wall -Wextra -Werror SFINAE.cpp -o main

#include &lt;iostream&gt;
#include &lt;typeinfo&gt;
#include &lt;type_traits&gt;

typedef unsigned char byte;

template &lt;typename T&gt;
class CheckSerialize {
    typedef char Small;
    struct Big { char x[2]; };
public:
    // Check for serialize
    template &lt;typename U&gt; static Small test(decltype(&U::serialize));
    
    // Check otherwise
    template &lt;typename U&gt; static Big test(...);
    
    // Store Values
    enum {
        Yes = (sizeof(test&lt;T&gt;(0)) == sizeof(Small)),
        No = !Yes
    };
};


// Foo class with a serialize
class Foo {
    int x;
public:
    Foo(int x_) : x(x_) {}

    void serialize(std::ostream& os) {
        os &lt;&lt; "Foo: " &lt;&lt; x;
        os &lt;&lt; '\n';
    }
};


class Bar {
public:
    int x = -1;
};


// General Purpose serialize
template &lt;typename T, typename std::enable_if&lt;CheckSerialize&lt;T&gt;::No, T&gt;::type* = nullptr&gt;
void serialize(std::ostream& os, T& obj)  {
    byte *c = reinterpret_cast&lt;byte *&gt;(&obj);

    for (int i = 0; i &lt; sizeof(T); ++i) {
        os &lt;&lt; (int)c[i] &lt;&lt; ", ";
    }
    os &lt;&lt; '\n';
}

template &lt;typename T, typename std::enable_if&lt;CheckSerialize&lt;T&gt;::Yes, T&gt;::type* = nullptr&gt;
void serialize(std::ostream& os, T& obj)  {
    obj.serialize(os);
}


int main()
{
    Foo f(20);
    
    Bar b;
    
    serialize(std::cout, f);
    serialize(std::cout, b);

    return 0;
}
// ----------
Foo: 20
255, 255, 255, 255, 
                        </code>
                    </pre>
                </div>
                <h3>Concluding Remarks</h3>
                <p>
                    On concluding notes, Turing Completeness is merely used to determine if a system can evaluate some computational data.
                    The test does not account for the ability to program <i>anything</i>; a typical I/O bound program quickly surpasses
                    Turing Completeness as the system had to conquer computing anything before input, output, and interrupts can be implemented.
                    Most Turing Complete systems do not account as far as dynamic input--unless you count the infinitely long tape as dynamic. A Turing 
                    Complete System is, at the end of the day, a Finite State Machine.
                </p>
                <h4>Finite State Machines</h4>
                <p>
                    A Finite State Machine (FSM) maintains a current state and an execution table for what to do in the current state. The execution
                    table determines the next state of the machine based on the current state. To represent these states we use a symbol, denoting the state,
                    and an arrow to a possible next state. If you wish to read more about FSM, I recommend <a href="https://www.i-programmer.info/babbages-bag/223-finite-state-machines.html">here to start</a><br><br>
                    <center><img src="FSM.png" ></center>
                </p>

                <h3>Write Up</h3>
                <p>
                    This project was a thin veil to look further into C++ Metaprogramming. I took this project on by myself and I didn't want to do just Metaprogramming since
                    I figured someone else discuss such a topic; granted it would be to have two such projects, but for the sake of 
                    diversity I chose to get some insight into Turing Completeness. This project takes a look at when a system of rules
                    becomes a Turing Complete System, a system which can make decisions to compute some resulting value(s). Particularly this project
                    looked into what the line between these two definitions (Turing Complete and Not). <br>
                    <br>All code developed for this project is embedded into this webpage, but to reduce a copy paste error here is the <a href="SFINAE.zip">SFINAE Code</a>.<br>
                    <br>Given the topic of C++ Metaprogramming, I felt this project definitely met the CS3XX complexity in O(1) time complexity. However, I did
                    not meet all of my goals for this project. I failed to write a Turing Machine in any of the languages. The time spent researching for C++ Templates, as
                    well as school, took precedence over completing this goal.
                </p>

                <h4>Credits</h4>
                <p>
                    <ul>
                        <li>Diagrams: <a href="https://www.draw.io/">DrawIO</a></li>
                        <li>Code: <a href="https://highlightjs.org/">HighlightJS</a></li>
                        <li>The Meaning of Life: <a href="../conwayjs/index.html">Life with Rules</a></li>
                    </ul>
                </p>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="text-center">
        <div class="footer-above">
            <div class="container">
                <div class="row">
                    <div class="footer-col col-md-4">
                        <h3><a href="duck.jpg" target="_blank">Link</a></h3>
                    </div>
                    <div class="footer-col col-md-4">
                        <h3>You made it far.</h3>
                    </div>
                    <div class="footer-col col-md-4">
                        <h3><a href="https://www.draw.io/">draw.io</a></h3>
                    </div>
                </div>
            </div>
        </div>
        <div class="footer-below">
            <div class="container">
                <div class="row">
                    <div class="col-lg-12">
                        Copyright &copy; Noah Sweet 3000
                    </div>
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap core JavaScript -->
    <script src="vendor/jquery/jquery.min.js"></script>
    <script src="vendor/tether/tether.min.js"></script>
    <script src="vendor/bootstrap/js/bootstrap.min.js"></script>

    <!-- Plugin JavaScript -->
    <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

    <!-- Contact Form JavaScript -->
    <script src="js/jqBootstrapValidation.js"></script>
    <script src="js/contact_me.js"></script>

    <!-- Custom scripts for this template -->
    <script src="js/freelancer.min.js"></script>

</body>

</html>
